/*
 * Copyright (C) Aros Bio AB.
 *
 * CPSign is an Open Source Software that is dual licensed to allow you to choose a license that best suits your requirements:
 *
 * 1) GPLv3 (GNU General Public License Version 3) with Additional Terms, including an attribution clause as well as a limitation to use the software for commercial purposes.
 *
 * 2) CPSign Proprietary License that allows you to use CPSign for commercial activities, such as in a revenue-generating operation or environment, or integrate CPSign in your proprietary software without worrying about disclosing the source code of your proprietary software, which is required if you choose to use the software under GPLv3 license. See arosbio.com/cpsign/commercial-license for details.
 */
package com.arosbio.cpsign.app;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.apache.commons.text.WordUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.arosbio.cheminf.ChemCPClassifier;
import com.arosbio.cheminf.ChemCPRegressor;
import com.arosbio.cheminf.ChemPredictor;
import com.arosbio.cheminf.data.ChemDataset;
import com.arosbio.cheminf.io.ModelSerializer;
import com.arosbio.cpsign.app.params.mixins.ConsoleVerbosityMixin;
import com.arosbio.cpsign.app.params.mixins.EchoMixin;
import com.arosbio.cpsign.app.params.mixins.EncryptionMixin;
import com.arosbio.cpsign.app.params.mixins.LogfileMixin;
import com.arosbio.cpsign.app.params.mixins.OutputJARMixin;
import com.arosbio.cpsign.app.params.mixins.ProgramProgressMixin;
import com.arosbio.cpsign.app.utils.CLIConsole;
import com.arosbio.cpsign.app.utils.CLIProgramUtils;
import com.arosbio.cpsign.app.utils.CLIProgressBar;
import com.arosbio.cpsign.app.utils.MissingParam;
import com.arosbio.cpsign.app.utils.MultipleModelLoader;
import com.arosbio.cpsign.app.utils.NullProgress;
import com.arosbio.cpsign.app.utils.ParameterUtils;
import com.arosbio.cpsign.app.utils.ProgramTimer;
import com.arosbio.cpsign.app.utils.CLIConsole.PrintMode;
import com.arosbio.cpsign.app.utils.CLIProgressBar.SupportsProgressBar;
import com.arosbio.cpsign.app.utils.ParameterUtils.ArgumentType;
import com.arosbio.cpsign.out.OutputNamingSettings.PB;
import com.arosbio.cpsign.out.OutputNamingSettings.ProgressInfoTexts;
import com.arosbio.ml.cp.acp.ACPClassifier;
import com.arosbio.ml.cp.acp.ACPRegressor;
import com.arosbio.ml.cp.icp.ICPClassifier;
import com.arosbio.ml.cp.icp.ICPRegressor;
import com.arosbio.ml.cp.tcp.TCP;
import com.arosbio.ml.interfaces.Predictor;
import com.arosbio.ml.io.ModelInfo;

import picocli.CommandLine.Command;
import picocli.CommandLine.Mixin;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.Option;
import picocli.CommandLine.Spec;

/*
 * PB.VALIDATE_PARAMS_PROGRESS
 * PB.AGGREGATING_MODELS_PROGRESS
 * PB.SAVING_JAR_PROGRESS
 */
@Command(
		name = Aggregate.CMD_NAME, 
		description = Aggregate.CMD_DESCRIPTION, 
		descriptionHeading = CPSignApp.DESCRIPTION_HEADER, 
		header = Aggregate.CMD_HEADER
		)
public class Aggregate implements RunnableCmd, SupportsProgressBar {

	private static final Logger LOGGER = LoggerFactory.getLogger(Aggregate.class);

	public final static String CMD_NAME = "aggregate";
	public final static String CMD_HEADER = "Aggregate data from multiple models";
	public static final String CMD_DESCRIPTION = "The aggregate command joins data from multiple models. "+
			"The models can either be precomputed data generated by"+
			" the @|bold precompute|@ program or trained ACP or VAP models "+
			"generated by the @|bold train|@ program. This program facilitate "+ 
			"a high level way of distributing the training step.";
	
	/*****************************************
	 * INTERNAL STATE
	 *****************************************/
	
	@Spec private CommandSpec spec;
	private CLIConsole console = CLIConsole.getInstance();
	private CLIProgressBar pb = new NullProgress();
	private ProgramTimer timer = new ProgramTimer(false, console);

	private MultipleModelLoader models;
	private int modelsSuccessfullyLoaded;
	private int modelsFailed;

	/*****************************************
	 * OPTIONS
	 *****************************************/

	// Input

	@Option(names ={"-m","--model-files"}, 
			description="A list (space or comma-separated) of models that should be aggregated. "+
					"Valid input is directories, glob patterns (with wildcard character '*'), explicit files or URIs. "+
					"Note that models can be a mix of non-encrypted and encrypted models.", 
					required = true,
					arity = ParameterUtils.LIST_TYPE_ARITY,
					split = ParameterUtils.SPLIT_WS_REGEXP,
					paramLabel = ArgumentType.URI_OR_PATH
			)
	private List<String> inputModels;

	@Option(names = {"-af", "--accept-fail"},
			description="Accept failure if a model cannot be added to the aggregated model (i.e. if model is of wrong type, does not have matching signatures, cannot be decrypted etc.). Default is to fail execution")
	private boolean acceptFail=false;

	// Model Jar options
	@Mixin
	private OutputJARMixin outputSection = new OutputJARMixin();

	// Encryption
	@Mixin
	private EncryptionMixin encryptSection = new EncryptionMixin();

	// General

	@Mixin
	private ProgramProgressMixin pbArgs;

	@Mixin
	private ConsoleVerbosityMixin consoleArgs;
	
	@Mixin
	private LogfileMixin loggingArgs;

	@Mixin
	private EchoMixin echo;
	
	/*****************************************
	 * END OF OPTIONS
	 *****************************************/

	@Override
	public String getName() {
		return CMD_NAME;
	}
	
	@Override
	public int getNumSteps() {
		return 3;
	}
	
	@Override
	public void setProgressBar(CLIProgressBar pb) {
		this.pb = pb;
	}

	@Override
	public Integer call() {

		CLIProgramUtils.doFullProgramConfig(this);
		
		assertAndSetupAggregate();
		LOGGER.debug("Validated arguments");
		pb.stepProgress();


		pb.setCurrentTask(PB.AGGREGATING_MODELS_PROGRESS);
		aggregate();

		// FINISH PROGRAM
		pb.finish();
		timer.endProgram();
		console.println("", PrintMode.NORMAL);
		return ExitStatus.SUCCESS.code;
	}

	private void aggregate(){
		LOGGER.debug("Starting to run AGGREGATE");

		// read in the first model - use that one as the basis
		//		console.startSection(PB.AGGREGATING_MODELS_PROGRESS);
		Object firstModel = loadFirstModel();
		modelsSuccessfullyLoaded++;
		pb.stepProgress();

		if (firstModel instanceof ChemDataset) {
			LOGGER.debug("aggregation is done on precomputed data");
			aggregatePrecomputed((ChemDataset) firstModel);
		} else if (firstModel instanceof ChemCPClassifier) {
			LOGGER.debug("Aggregating in trained classification mode");
			aggregateTrainedClassification((ChemCPClassifier) firstModel);
		} else if (firstModel instanceof ChemCPRegressor){
			LOGGER.debug("Aggregating in trained regression mode");
			aggregateTrainedRegression((ChemCPRegressor) firstModel);
		} else {
			LOGGER.debug("First model was of type " + firstModel.getClass().getCanonicalName() + " which is currently not supported");
			console.failWithArgError("aggregate does not support aggregation of " + 
					getModelType(firstModel) + " models");
		}

	}

	private Object loadFirstModel() {
		LOGGER.debug("trying to load the first model");
		try {
			return models.next();
		} catch (Exception e) {
			LOGGER.debug("Failed when loading model the inital model");
			failModel(e.getMessage());
			return loadFirstModel();
		}
	}

	private static final String INCOMPATIBLE_MODEL_ERR_MSG = "Model of incompatible type";

	private void aggregatePrecomputed(ChemDataset baseModel) {

		int modelIndex = modelsSuccessfullyLoaded+modelsFailed;
		console.println("Aggregating precomputed data sets...", PrintMode.NORMAL);
		console.println(" - Loaded model %s/%s", PrintMode.NORMAL,modelIndex , models.getTotalNum());
		while (models.hasNext()){
			modelIndex++;
			// Load the model
			ChemDataset model = null;
			Object tmp = null;
			try{
				tmp = models.next();
				model = (ChemDataset) tmp;
			} catch (ClassCastException e){
				faultyModelType(model);
				continue;
			} catch (Exception e){
				failModel(e.getMessage());
				continue;
			}

			// CLASSIFICATION: Check that labels are the same
			if (baseModel.getTextualLabels() != null) {

				if(model.getTextualLabels() == null){
					// Loaded model is not a precomputed classification model
					faultyModelType(model);
					continue; 
				} else { // correct model type - check labels

					Map<Integer,String> newLabels = model.getTextualLabels().getLabels(); 
					if (newLabels == null){
						failModel("Loaded model without any labels set: " + models.getLastLoadedURI());
						continue;
					} else if (newLabels.size()<2){
						failModel("Loaded model with less than 2 labels: " + models.getLastLoadedURI());
						continue;
					}
					if(! newLabels.equals(baseModel.getTextualLabels().getLabels())){
						failModel("Loaded model with labels: " + newLabels + 
								", previous found labels: " + baseModel.getTextualLabels().getLabels() + " (model: "+models.getLastLoadedURI() +")");
						continue;
					}
				}
			}
			

			// If we got here, the model must be OK
			try {
				baseModel.joinShallow(model);
			} catch(IllegalArgumentException e){
				failModel("Failed aggregating data: " + models.getLastLoadedURI() +", Reason: "+e.getMessage());
				continue;
			} catch(Exception e){
				LOGGER.debug("Encountered Exception trying to join ChemDataset",e);
				failModel("Failed aggregating data: " + models.getLastLoadedURI() +", Reason: "+e.getMessage());
				continue;
			}

			console.println(" - Aggregated data set %s/%s", PrintMode.NORMAL, modelIndex, models.getTotalNum());
			modelsSuccessfullyLoaded++;
			pb.stepProgress();
		} // End of for-loop over modelsToAggregate
		// End the loading/aggregating section


		failIfNotEnoughModelsAggregated();
		if (modelsFailed>0)
			console.println("Successfully aggregated "+ modelsSuccessfullyLoaded +" precomputed data sets, failed to load " + modelsFailed +" data set"+(modelsFailed>1?"s":""), PrintMode.NORMAL);
		else
			console.println("Successfully aggregated "+ modelsSuccessfullyLoaded +" precomputed data sets", PrintMode.NORMAL);

		timer.endSection();
		pb.stepProgress();


		//
		// Save the model
		// 
		pb.setCurrentTask(PB.SAVING_JAR_PROGRESS);
	

		try {
			console.print(WordUtils.wrap("Saving aggregated data set to file: " + outputSection.modelFile + ProgressInfoTexts.SPACE_ELLIPSES, console.getTextWidth()), 
					PrintMode.NORMAL);
			ModelSerializer.saveDataset(baseModel,
					new ModelInfo(outputSection.modelName, 
						outputSection.modelVersion, outputSection.modelCategory),
					outputSection.modelFile, 
					encryptSection.exclusive.encryptSpec, 
					outputSection.dataToMount);
		} catch (Exception e){
			LOGGER.debug("Failed creating aggregated model-bundle", e);
			console.failWithArgError("Failed creating aggregated precomputed data set, Reason: " + e.getMessage());
		}
		console.print(ProgressInfoTexts.DONE_TAG, PrintMode.NORMAL);
		pb.stepProgress();
		timer.endSection();

	}

	private void aggregateTrainedClassification(ChemCPClassifier baseModel) {

		if(!(baseModel.getPredictor() instanceof ACPClassifier))
			console.failWithArgError("One of the models did not have a ACP classification Predictor");

		ACPClassifier acpPredictor = (ACPClassifier) baseModel.getPredictor();

		int modelIndex = modelsSuccessfullyLoaded+modelsFailed;
		console.println("Aggregating classification models...", PrintMode.NORMAL);
		console.println(" - Loaded model %s/%s", PrintMode.NORMAL, modelIndex, models.getTotalNum());
		while (models.hasNext()){
			modelIndex++;
			// Load the model
			ChemCPClassifier model = null;
			try{
				model = (ChemCPClassifier) models.next(); 
			} catch (ClassCastException e){
				failModel(INCOMPATIBLE_MODEL_ERR_MSG);
				continue;
			} catch (Exception e){
				failModel(e.getMessage());
				continue;
			}

			// If model is of wrong type
			if(! (model instanceof ChemCPClassifier) || 
					!(((ChemCPClassifier)model).getPredictor() instanceof ACPClassifier)){
				faultyModelType(model);
				continue;
			}
			ChemCPClassifier signClassLoaded = (ChemCPClassifier) model;

			// labels must match!
			Map<Integer,String> newLabels = signClassLoaded.getLabels();
			if (newLabels == null){
				failModel("Loaded model without any labels set: " + models.getLastLoadedURI());
				continue;
			} else if (newLabels.size()<2){
				failModel("Loaded model with less than 2 labels: " + models.getLastLoadedURI());
				continue;
			}

			if(! newLabels.equals(baseModel.getLabels())){
				failModel("Loaded model with labels: " + newLabels + 
						", previous found labels: " + baseModel.getLabels() + " (model: "+models.getLastLoadedURI() +")");
				continue;
			}

			// Make sure signatures are the same
			if (! baseModel.getDataset().equalDescriptors(signClassLoaded.getDataset())){
				failModel("Could not merge problems due to different signatures");
				continue;
			}


			// If we got here, everything should be OK
			try{
				ACPClassifier loadedACP = (ACPClassifier) signClassLoaded.getPredictor();
				for(Map.Entry<Integer, ICPClassifier> entry: loadedACP.getPredictors().entrySet()){
					acpPredictor.addICP(entry.getValue(), entry.getKey());
				}

			} catch(IllegalArgumentException e){
				LOGGER.debug("Could not join in model: " + models.getLastLoadedURI(), e);
				failModel("Could not aggreagate model: " + models.getLastLoadedURI() + ", Reason: " + e.getMessage());
				continue;
			} catch(Exception e){
				LOGGER.debug("Encountered Exception trying to join SignaturesProblems",e);
				failModel("Failed aggregating model: " + models.getLastLoadedURI() +", Reason: "+e.getMessage());
				continue;
			}

			console.println(" - Aggregated model " + modelIndex + '/' + models.getTotalNum(), PrintMode.NORMAL);
			modelsSuccessfullyLoaded++;
			pb.stepProgress();
		} // End for-loop modelsToAggregate

		// End the loading/aggregating section
		timer.endSection();

		failIfNotEnoughModelsAggregated();

		int totalNumICPs = ((ACPClassifier) baseModel.getPredictor()).getNumTrainedPredictors();
		if(modelsFailed>0)
			console.println("Successfully aggregated "+ modelsSuccessfullyLoaded +
					" trained classification models (in total "+totalNumICPs +" ICPs), failed to load " + modelsFailed +" model"+(modelsFailed>1?"s":""), PrintMode.NORMAL);
		else
			console.println("Successfully aggregated "+ modelsSuccessfullyLoaded +" trained classification models (in total "+totalNumICPs +" ICPs)", PrintMode.NORMAL);

		saveModel(baseModel);

	}

	private void aggregateTrainedRegression(ChemCPRegressor baseModel) {

		if(!(baseModel.getPredictor() instanceof ACPRegressor))
			console.failWithArgError("One of the models did not have a ACP regression Predictor");

		ACPRegressor acpPredictor = (ACPRegressor) baseModel.getPredictor();

		int modelIndex = modelsSuccessfullyLoaded+modelsFailed;
		console.println("Aggregating regression models...", PrintMode.NORMAL);
		console.println(" - Loaded model %s/%s", PrintMode.NORMAL,modelIndex, models.getTotalNum());
		while (models.hasNext()){
			modelIndex++;
			// Load the model
			ChemCPRegressor model = null;
			try{
				model = (ChemCPRegressor) models.next(); 
			} catch (ClassCastException e){
				failModel(INCOMPATIBLE_MODEL_ERR_MSG);
				continue;
			} catch (Exception e){
				failModel(e.getMessage());
				continue;
			}

			// If model is of wrong type
			if(! (model instanceof ChemCPRegressor) || !(((ChemCPRegressor)model).getPredictor() instanceof ACPRegressor) ){
				faultyModelType(model);
				continue;
			}

			ChemCPRegressor loaded = (ChemCPRegressor) model;

			// Make sure signatures are the same
			if (! baseModel.getDataset().equalDescriptors(loaded.getDataset())){
				failModel("Could not merge problems due to different signatures");
				continue;
			}

			// If we got here, everything should be OK
			try{
				ACPRegressor loadedACP = (ACPRegressor) loaded.getPredictor();
				for(Map.Entry<Integer, ICPRegressor> entry: loadedACP.getPredictors().entrySet()){
					acpPredictor.addICP(entry.getValue(), entry.getKey());
				}
			} catch(IllegalArgumentException e){
				LOGGER.debug("Could not join in model: " + models.getLastLoadedURI(), e);
				failModel("Could not aggreagate model: " + models.getLastLoadedURI() + ", Reason: " + e.getMessage());
				continue;
			} catch(Exception e){
				LOGGER.debug("Encountered Exception trying to join ChemDatasets",e);
				failModel("Failed aggregating model: " + models.getLastLoadedURI() +", Reason: "+e.getMessage());
				continue;
			}

			console.println(" - Aggregated model %s/%s", PrintMode.NORMAL, modelIndex, models.getTotalNum());
			modelsSuccessfullyLoaded++;
			pb.stepProgress();
		} // End for-loop modelsToAggregate
		//		console.endSection();
		timer.endSection();
		//		pb.stepProgress();

		failIfNotEnoughModelsAggregated();

		int totalNumICPs = acpPredictor.getNumTrainedPredictors();

		if(modelsFailed>0)
			console.printlnWrapped("Successfully aggregated "+ modelsSuccessfullyLoaded +" trained regression models (in total "+totalNumICPs +" ICPs), failed to load " + modelsFailed +" model"+(modelsFailed>1?"s":""),PrintMode.NORMAL);
		else
			console.printlnWrapped("Successfully aggregated "+ modelsSuccessfullyLoaded +" trained regression models (in total "+totalNumICPs +" ICPs)", PrintMode.NORMAL);


		saveModel(baseModel);

	}

	private void faultyModelType(Object model){
		failModel("Could not aggregate model of type " + getModelType(model) + ": " + models.getLastLoadedURI());
	}

	private void failModel(String reason){
		modelsFailed++;
		LOGGER.debug("failing model due to reason: {}", reason);
		console.println(" - Failed loading model "+(models.getNumFailed()+models.getNumSuccessful())+'/'+models.getTotalNum() + " ("+models.getLastLoadedURI()+')', PrintMode.NORMAL);
		if (! acceptFail)
			console.failWithArgError(reason);
		pb.stepProgress(); // step even though failed a model
	}

	private void failIfNotEnoughModelsAggregated() {
		if (modelsSuccessfullyLoaded == 0)
			console.failWithArgError("No models could successfully be loaded and aggregated!");
		if (modelsSuccessfullyLoaded == 1)
			console.failWithArgError("Only one model could be loaded, no aggregated model will be written");
	}

	private void assertAndSetupAggregate() {

		// Make sure we have train priv and get auth
		// encryptSpec = CLIProgramUtils.getEncryptSpec(console, 
		// 		null, //TODO 
		// 		encryptSection.encryptLicense, 
		// 		encryptSection.yubiKeyPin);

		// Check models were given and resolve to proper uri's
		if (inputModels == null || 
				inputModels.isEmpty())
			console.failDueToMissingParameters(new MissingParam("inputModels", "MODELS", Aggregate.class));

		// Parse URIs, paths, directories etc into a list of URIs
		try {
			models = new MultipleModelLoader(inputModels, encryptSection.exclusive.encryptSpec);
		} catch (IOException e) {
			LOGGER.debug("Failed setting up the resources to aggregate",e);
			console.failWithArgError("Invalid model input: " + e.getMessage());
		}
		if (!models.hasNext())
			console.failWithArgError("Parameter " + CLIProgramUtils.getParamName(this, "inputModels", "MODELS") +
					" could not be resolved to any valid uris or paths");
		LOGGER.debug("Total number of models to aggregate is " + models.getTotalNum());

		// Update the progress-bar max num steps
		pb.addAdditionalSteps(models.getTotalNum()-1); // -1 for already set 1 model as default

		// Set up the final output-model including parent folders
		///////////////
		// Model Jar //
		///////////////
		try {
			CLIProgramUtils.setupOutputModelFile(outputSection.modelFile, this);
		} catch (IOException e) {
			LOGGER.debug("Failed setting up the output JAR-model file",e);
			console.failWithArgError("Could not setup the output model");
		}

		if (outputSection.modelName == null || outputSection.modelName.isEmpty()) {
			outputSection.modelName = CLIProgramUtils.getModelNameFromFileName(outputSection.modelFile);
			LOGGER.debug("No model-name given, setting it to: " + outputSection.modelName);
		}
	}

	private String getModelType(Object model){
		if (model instanceof ChemDataset){
			if (((ChemDataset)model).getTextualLabels() != null){
				return "precomputed classification data";
			} else {
				return "precomputed regression data";
			}
		} else if (model instanceof ChemCPRegressor)
			return "acp regression model";
		else if (model instanceof ChemCPClassifier && ((ChemCPClassifier) model).getPredictor() instanceof TCP)
			return "tcp classification model";
		else if (model instanceof ChemCPClassifier)
			return "acp classification model";
		else if (model instanceof Predictor)
			return "non-signatures predictor model";
		else
			return "not recognizable model";
	}

	private void saveModel(ChemPredictor predictor) {
		console.print(WordUtils.wrap("Saving aggregated model to file: " + outputSection.modelFile + ProgressInfoTexts.SPACE_ELLIPSES, console.getTextWidth()).trim(), 
				PrintMode.NORMAL);
		pb.setCurrentTask(PB.SAVING_JAR_PROGRESS);

		predictor.withModelInfo(new ModelInfo(outputSection.modelName, 
				outputSection.modelVersion, 
				outputSection.modelCategory));
		try{
			ModelSerializer.saveModel(predictor, 
					outputSection.modelFile, 
					encryptSection.exclusive.encryptSpec, 
					outputSection.dataToMount);
		} catch (Exception e){
			LOGGER.debug("Exception while generating Modeling JAR for trained predictor", e);
			console.println(' '+ProgressInfoTexts.FAILED_TAG, PrintMode.NORMAL);
			console.failWithInternalError("Failed when generating Model JAR: " + e.getMessage());
		}
		console.println(' '+ProgressInfoTexts.DONE_TAG, PrintMode.NORMAL);
	}


}
